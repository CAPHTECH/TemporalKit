# Debugging Counterexamples

This tutorial explains how to interpret and debug counterexamples generated by TemporalKit when model checking fails. Understanding counterexamples is crucial for diagnosing issues in your models and formulas.

## Prerequisites

Before starting this tutorial, make sure you have:

- Completed the [Basic Usage](./BasicUsage.md) tutorial
- Completed the [Modeling State Machines](./StateMachines.md) tutorial
- Understood LTL formulas and verification concepts
- Imported TemporalKit in your project

## Understanding Counterexamples

When TemporalKit's model checker verifies that a property does not hold for a given model, it provides a *counterexample* - a specific execution path through the model that demonstrates why the property is violated. Counterexamples are valuable debugging tools as they:

1. Show exactly how the property can be violated
2. Help you understand model behaviors you may not have considered
3. Provide concrete scenarios to fix in your implementation

There are two main types of counterexamples:

- **Finite counterexamples**: A finite path that violates a safety property
- **Lasso-shaped counterexamples**: An infinite path with a repeating suffix that violates a liveness property

## 1. Basic Counterexample Structure

Let's start with a simple example to understand the structure of counterexamples:

```swift
import TemporalKit

// Define a simple state machine
enum TrafficLightState: Hashable {
    case red
    case yellow
    case green
}

// Define a model with a flaw
struct FlawedTrafficLightModel: KripkeStructure {
    typealias State = TrafficLightState
    typealias AtomicPropositionIdentifier = String
    
    let allStates: Set<TrafficLightState> = [.red, .yellow, .green]
    let initialStates: Set<TrafficLightState> = [.red]
    
    func successors(of state: TrafficLightState) -> Set<TrafficLightState> {
        switch state {
        case .red:
            return [.green] // FLAW: Red should go to green through yellow
        case .yellow:
            return [.red]
        case .green:
            return [.yellow]
        }
    }
    
    func atomicPropositionsTrue(in state: TrafficLightState) -> Set<String> {
        switch state {
        case .red:
            return ["isRed"]
        case .yellow:
            return ["isYellow"]
        case .green:
            return ["isGreen"]
        }
    }
}

// Define propositions
let isRed = TemporalKit.makeProposition(
    id: "isRed",
    name: "Light is red",
    evaluate: { $0 == TrafficLightState.red }
)

let isYellow = TemporalKit.makeProposition(
    id: "isYellow",
    name: "Light is yellow",
    evaluate: { $0 == TrafficLightState.yellow }
)

let isGreen = TemporalKit.makeProposition(
    id: "isGreen",
    name: "Light is green",
    evaluate: { $0 == TrafficLightState.green }
)

// Define property: "Red must be followed by yellow"
let redMustBeFollowedByYellow = LTLFormula<ClosureTemporalProposition<TrafficLightState, Bool>>.globally(
    .implies(
        .atomic(isRed),
        .next(.atomic(isYellow))
    )
)

// Create model checker and verify
let modelChecker = LTLModelChecker<FlawedTrafficLightModel>()
let model = FlawedTrafficLightModel()

do {
    let result = try modelChecker.check(formula: redMustBeFollowedByYellow, model: model)
    print("Verification result: \(result)")
} catch {
    print("Verification error: \(error)")
    
    if let checkError = error as? LTLModelCheckerError<TrafficLightState> {
        switch checkError {
        case .formulaViolated(let counterexample):
            print("Counterexample found:")
            printCounterexample(counterexample)
        default:
            print("Other error: \(error)")
        }
    }
}

// Helper function to print counterexample
func printCounterexample(_ counterexample: ModelCheckResult<TrafficLightState>.Counterexample) {
    print("States in the counterexample:")
    
    for (index, state) in counterexample.states.enumerated() {
        print("Step \(index): \(state)")
    }
    
    if let loop = counterexample.loop {
        print("Loop starts at index: \(loop)")
    }
}
```

When running this code, you'll get a counterexample showing that the property "red must be followed by yellow" is violated. The counterexample will show a path like:

```
Step 0: red
Step 1: green
```

This demonstrates that our model incorrectly allows a direct transition from red to green, violating our property that red should be followed by yellow.

## 2. Visualizing Counterexamples

For more complex counterexamples, it helps to visualize the states and transitions. Here's a way to create a more detailed visualization:

```swift
// Improved counterexample visualization
func visualizeCounterexample<State>(
    counterexample: ModelCheckResult<State>.Counterexample,
    getPropositions: (State) -> Set<String>
) {
    print("\n=========== COUNTEREXAMPLE ===========")
    print("Path showing property violation:")
    
    let states = counterexample.states
    
    for (index, state) in states.enumerated() {
        let isLoopStart = counterexample.loop == index
        let loopMarker = isLoopStart ? "↩️" : " "
        let propositions = getPropositions(state).joined(separator: ", ")
        
        print("\(loopMarker) Step \(index): State \(state)")
        print("   True propositions: [\(propositions)]")
        
        // Show transition arrow except for last state
        if index < states.count - 1 {
            print("   ↓")
        }
    }
    
    // Show loop if present
    if let loopIndex = counterexample.loop {
        print("\n   ↑                                 ↓")
        print("   └────────── LOOP BACK ──────────┘")
        print("   (State at index \(loopIndex) repeats infinitely)")
    }
    
    print("=======================================\n")
}

// Usage with our traffic light example
if let checkError = error as? LTLModelCheckerError<TrafficLightState> {
    switch checkError {
    case .formulaViolated(let counterexample):
        visualizeCounterexample(
            counterexample: counterexample,
            getPropositions: model.atomicPropositionsTrue(in:)
        )
    default:
        print("Other error: \(error)")
    }
}
```

This visualization helps you understand:
- The sequence of states in the counterexample
- Which propositions are true at each state
- Where loops begin in infinite counterexamples

## 3. Debugging Safety Property Violations

Safety properties assert that "nothing bad happens" and are violated by finite counterexamples. Let's look at how to debug a safety property violation:

```swift
// Define a more complex state machine for a login system
enum LoginState: Hashable {
    case loggedOut
    case enteringCredentials
    case processingLogin
    case loggedIn
    case failedLogin
    case lockedOut
}

// Model with security flaws
struct FlawedLoginModel: KripkeStructure {
    typealias State = LoginState
    typealias AtomicPropositionIdentifier = String
    
    // Track failed login attempts
    var failedAttempts: Int = 0
    let maxFailedAttempts = 3
    
    let allStates: Set<LoginState> = [
        .loggedOut, .enteringCredentials, .processingLogin, 
        .loggedIn, .failedLogin, .lockedOut
    ]
    
    let initialStates: Set<LoginState> = [.loggedOut]
    
    func successors(of state: LoginState) -> Set<LoginState> {
        switch state {
        case .loggedOut:
            return [.enteringCredentials]
            
        case .enteringCredentials:
            return [.processingLogin]
            
        case .processingLogin:
            return [.loggedIn, .failedLogin]
            
        case .loggedIn:
            return [.loggedOut]
            
        case .failedLogin:
            // FLAW: Should check if we exceed max attempts and go to lockedOut
            return [.enteringCredentials]
            
        case .lockedOut:
            return [.lockedOut] // Permanent lockout (for simplicity)
        }
    }
    
    func atomicPropositionsTrue(in state: LoginState) -> Set<String> {
        var props: Set<String> = []
        
        switch state {
        case .loggedOut:
            props.insert("isLoggedOut")
            
        case .enteringCredentials:
            props.insert("isEnteringCredentials")
            
        case .processingLogin:
            props.insert("isProcessingLogin")
            
        case .loggedIn:
            props.insert("isLoggedIn")
            props.insert("hasAccess")
            
        case .failedLogin:
            props.insert("isFailedLogin")
            
        case .lockedOut:
            props.insert("isLockedOut")
        }
        
        return props
    }
}

// Define a safety property: "After 3 failed attempts, account must be locked"
// (We'll simplify by saying we should never see more than 3 consecutive failed logins)
// Note: This simplified example demonstrates the concept but doesn't actually count failures

let failedLoginProp = TemporalKit.makeProposition(
    id: "isFailedLogin",
    name: "Login failed",
    evaluate: { $0 == LoginState.failedLogin }
)

let lockedOutProp = TemporalKit.makeProposition(
    id: "isLockedOut",
    name: "Account is locked out",
    evaluate: { $0 == LoginState.lockedOut }
)

let noMoreThanThreeFailures = LTLFormula<ClosureTemporalProposition<LoginState, Bool>>.globally(
    .not(
        .and(
            .atomic(failedLoginProp),
            .next(
                .and(
                    .atomic(failedLoginProp),
                    .next(
                        .and(
                            .atomic(failedLoginProp),
                            .next(.atomic(failedLoginProp))
                        )
                    )
                )
            )
        )
    )
)

// Check the property
let loginModelChecker = LTLModelChecker<FlawedLoginModel>()
let loginModel = FlawedLoginModel()

do {
    let result = try loginModelChecker.check(formula: noMoreThanThreeFailures, model: loginModel)
    print("Verification result: \(result)")
} catch {
    print("Verification error: \(error)")
    
    if let checkError = error as? LTLModelCheckerError<LoginState> {
        switch checkError {
        case .formulaViolated(let counterexample):
            visualizeCounterexample(
                counterexample: counterexample,
                getPropositions: loginModel.atomicPropositionsTrue(in:)
            )
            
            // Analyze the counterexample
            analyzeLoginCounterexample(counterexample)
        default:
            print("Other error: \(error)")
        }
    }
}

// Helper function to analyze login counterexample
func analyzeLoginCounterexample(_ counterexample: ModelCheckResult<LoginState>.Counterexample) {
    print("=== ANALYSIS ===")
    
    // Count consecutive failed logins
    var maxConsecutiveFailures = 0
    var currentConsecutiveFailures = 0
    
    for state in counterexample.states {
        if state == .failedLogin {
            currentConsecutiveFailures += 1
            maxConsecutiveFailures = max(maxConsecutiveFailures, currentConsecutiveFailures)
        } else {
            currentConsecutiveFailures = 0
        }
    }
    
    print("Maximum consecutive failed logins: \(maxConsecutiveFailures)")
    
    // Check if lockout state is ever reached
    let reachesLockout = counterexample.states.contains(.lockedOut)
    print("Account gets locked out: \(reachesLockout)")
    
    print("Issue: The model allows unlimited login attempts without lockout.")
    print("Fix: Modify the model to transition to lockedOut after 3 consecutive failures.")
}
```

The counterexample for this safety property will show that you can have a long sequence of failed login attempts without ever reaching the locked out state.

## 4. Debugging Liveness Property Violations

Liveness properties assert that "something good eventually happens" and are violated by infinite counterexamples with loops. Let's debug a liveness property violation:

```swift
// Define a state machine for a resource allocation system
enum ResourceState: Hashable {
    case idle
    case requested
    case allocated
    case releasing
    case error
}

// Model with a liveness bug
struct ResourceModel: KripkeStructure {
    typealias State = ResourceState
    typealias AtomicPropositionIdentifier = String
    
    let allStates: Set<ResourceState> = [
        .idle, .requested, .allocated, .releasing, .error
    ]
    
    let initialStates: Set<ResourceState> = [.idle]
    
    func successors(of state: ResourceState) -> Set<ResourceState> {
        switch state {
        case .idle:
            return [.idle, .requested]
            
        case .requested:
            // LIVENESS BUG: Request might stay in requested state forever
            // There's no guarantee it will ever progress to allocated
            return [.requested, .allocated, .error]
            
        case .allocated:
            return [.releasing, .error]
            
        case .releasing:
            return [.idle, .error]
            
        case .error:
            return [.idle]
        }
    }
    
    func atomicPropositionsTrue(in state: ResourceState) -> Set<String> {
        switch state {
        case .idle:
            return ["isIdle", "isAvailable"]
        case .requested:
            return ["isRequested", "isPending"]
        case .allocated:
            return ["isAllocated", "isInUse"]
        case .releasing:
            return ["isReleasing", "isPending"]
        case .error:
            return ["isError"]
        }
    }
}

// Propositions
let isRequested = TemporalKit.makeProposition(
    id: "isRequested",
    name: "Resource is requested",
    evaluate: { $0 == ResourceState.requested }
)

let isAllocated = TemporalKit.makeProposition(
    id: "isAllocated",
    name: "Resource is allocated",
    evaluate: { $0 == ResourceState.allocated }
)

// Liveness property: "Every request is eventually allocated or errors"
let requestsEventuallyResolved = LTLFormula<ClosureTemporalProposition<ResourceState, Bool>>.globally(
    .implies(
        .atomic(isRequested),
        .eventually(
            .or(
                .atomic(isAllocated),
                .atomic(TemporalKit.makeProposition(
                    id: "isError",
                    name: "Resource is in error state",
                    evaluate: { $0 == ResourceState.error }
                ))
            )
        )
    )
)

// Check the property
let resourceModelChecker = LTLModelChecker<ResourceModel>()
let resourceModel = ResourceModel()

do {
    let result = try resourceModelChecker.check(formula: requestsEventuallyResolved, model: resourceModel)
    print("Verification result: \(result)")
} catch {
    print("Verification error: \(error)")
    
    if let checkError = error as? LTLModelCheckerError<ResourceState> {
        switch checkError {
        case .formulaViolated(let counterexample):
            visualizeCounterexample(
                counterexample: counterexample,
                getPropositions: resourceModel.atomicPropositionsTrue(in:)
            )
            
            analyzeLivenessCounterexample(counterexample)
        default:
            print("Other error: \(error)")
        }
    }
}

// Helper function to analyze liveness counterexample
func analyzeLivenessCounterexample(_ counterexample: ModelCheckResult<ResourceState>.Counterexample) {
    print("=== LIVENESS ANALYSIS ===")
    
    guard let loopIndex = counterexample.loop else {
        print("This is not a liveness counterexample (no loop)")
        return
    }
    
    // Get the loop states - these repeat forever
    let loopStates = Array(counterexample.states[loopIndex...])
    
    print("States in the infinite loop:")
    for state in loopStates {
        print("- \(state)")
    }
    
    let requestedInLoop = loopStates.contains(.requested)
    let allocatedInLoop = loopStates.contains(.allocated)
    let errorInLoop = loopStates.contains(.error)
    
    if requestedInLoop && !allocatedInLoop && !errorInLoop {
        print("Issue found: Request can stay in requested state forever without resolution")
        print("Fix: Ensure requests can't stay in requested state indefinitely - add a timeout")
    }
}
```

The liveness counterexample will likely show a scenario where the resource gets stuck in the requested state forever, never proceeding to allocated or error states.

## 5. Common Counterexample Patterns and Fixes

Let's examine some common patterns in counterexamples and how to fix the underlying issues:

### Pattern 1: Missing Transitions

**Example Counterexample**: A state machine that should always reach a certain state but doesn't have the necessary transitions.

**Fix**: Add the missing transitions to ensure all reachable states have a path to the required state.

```swift
// Before
case .requested:
    return [.requested, .error] // Missing transition to .allocated

// After
case .requested:
    return [.requested, .allocated, .error] // Added transition to .allocated
```

### Pattern 2: Unintended Loops

**Example Counterexample**: A state can cycle endlessly without making progress.

**Fix**: Add timeout or progress conditions to force advancement.

```swift
// Before - can loop forever
case .processing:
    return [.processing, .completed]

// After - add a timeout mechanism
case .processing:
    // If we've been processing too long, force error state
    if processingTime > timeout {
        return [.error]
    } else {
        return [.processing, .completed]
    }
```

### Pattern 3: Incorrect Preconditions

**Example Counterexample**: A state is reached without satisfying necessary preconditions.

**Fix**: Strengthen the preconditions for state transitions.

```swift
// Before - can submit without validation
case .editing:
    return [.submitting, .validating]

// After - must validate before submitting
case .editing:
    return [.validating]
case .validating:
    return [.valid, .invalid]
case .valid:
    return [.submitting]
case .invalid:
    return [.editing]
```

### Pattern 4: Race Conditions

**Example Counterexample**: Multiple sequential operations that should be atomic can be interleaved.

**Fix**: Make operations atomic or add mutual exclusion.

```swift
// Before - separate check and update operations
case .checkingBalance:
    return [.sufficientFunds, .insufficientFunds]
case .sufficientFunds:
    return [.updatingBalance] // Race condition: balance could change between check and update

// After - atomic operation
case .transaction:
    return [.transactionSuccess, .transactionFailure] // Atomic check and update
```

## 6. Fixing the Models

After identifying issues using counterexamples, let's fix our models:

### Fixing the Traffic Light Model

```swift
// Fixed traffic light model
struct FixedTrafficLightModel: KripkeStructure {
    typealias State = TrafficLightState
    typealias AtomicPropositionIdentifier = String
    
    let allStates: Set<TrafficLightState> = [.red, .yellow, .green]
    let initialStates: Set<TrafficLightState> = [.red]
    
    func successors(of state: TrafficLightState) -> Set<TrafficLightState> {
        switch state {
        case .red:
            return [.yellow] // FIXED: Red transitions to yellow
        case .yellow:
            return [.green]  // Yellow transitions to green
        case .green:
            return [.yellow] // Green transitions to yellow
        }
    }
    
    func atomicPropositionsTrue(in state: TrafficLightState) -> Set<String> {
        switch state {
        case .red:
            return ["isRed"]
        case .yellow:
            return ["isYellow"]
        case .green:
            return ["isGreen"]
        }
    }
}

// Verify the fixed model
let fixedTrafficModel = FixedTrafficLightModel()
do {
    let result = try modelChecker.check(formula: redMustBeFollowedByYellow, model: fixedTrafficModel)
    print("Verification result for fixed traffic light model: \(result)")
} catch {
    print("Verification error: \(error)")
}
```

### Fixing the Login Model

```swift
// Fixed login model that implements lockout
struct FixedLoginModel: KripkeStructure {
    typealias State = (LoginState, Int) // State + failed attempt counter
    typealias AtomicPropositionIdentifier = String
    
    let maxFailedAttempts = 3
    
    var allStates: Set<State> {
        var states = Set<State>()
        for failCount in 0...maxFailedAttempts {
            states.insert((.loggedOut, failCount))
            states.insert((.enteringCredentials, failCount))
            states.insert((.processingLogin, failCount))
            states.insert((.loggedIn, 0)) // Reset counter on successful login
            states.insert((.failedLogin, failCount))
        }
        states.insert((.lockedOut, maxFailedAttempts))
        return states
    }
    
    let initialStates: Set<State> = [(.loggedOut, 0)]
    
    func successors(of state: State) -> Set<State> {
        let (loginState, failCount) = state
        
        switch loginState {
        case .loggedOut:
            return [(.enteringCredentials, failCount)]
            
        case .enteringCredentials:
            return [(.processingLogin, failCount)]
            
        case .processingLogin:
            // Can succeed or fail
            return [(.loggedIn, 0), (.failedLogin, failCount)]
            
        case .loggedIn:
            return [(.loggedOut, 0)] // Reset counter on logout
            
        case .failedLogin:
            let newFailCount = failCount + 1
            
            if newFailCount >= maxFailedAttempts {
                return [(.lockedOut, maxFailedAttempts)]
            } else {
                return [(.enteringCredentials, newFailCount)]
            }
            
        case .lockedOut:
            return [(.lockedOut, maxFailedAttempts)] // Stay locked out
        }
    }
    
    func atomicPropositionsTrue(in state: State) -> Set<String> {
        let (loginState, failCount) = state
        var props: Set<String> = []
        
        // Add basic state propositions
        switch loginState {
        case .loggedOut:
            props.insert("isLoggedOut")
            
        case .enteringCredentials:
            props.insert("isEnteringCredentials")
            
        case .processingLogin:
            props.insert("isProcessingLogin")
            
        case .loggedIn:
            props.insert("isLoggedIn")
            props.insert("hasAccess")
            
        case .failedLogin:
            props.insert("isFailedLogin")
            
        case .lockedOut:
            props.insert("isLockedOut")
        }
        
        // Add failure count propositions
        props.insert("failCount_\(failCount)")
        
        if failCount >= maxFailedAttempts {
            props.insert("tooManyFailures")
        }
        
        return props
    }
}

// Define a new safety property for the fixed model
let fixedFailedLoginProp = TemporalKit.makeProposition(
    id: "isFailedLogin",
    name: "Login failed",
    evaluate: { (state: (LoginState, Int)) in state.0 == .failedLogin }
)

let fixedTooManyFailuresProp = TemporalKit.makeProposition(
    id: "tooManyFailures",
    name: "Too many failures",
    evaluate: { (state: (LoginState, Int)) in state.1 >= 3 }
)

let fixedLockedOutProp = TemporalKit.makeProposition(
    id: "isLockedOut",
    name: "Account is locked out",
    evaluate: { (state: (LoginState, Int)) in state.0 == .lockedOut }
)

// Property: "Too many failures leads to lockout"
let tooManyFailuresLeadsToLockout = LTLFormula<ClosureTemporalProposition<(LoginState, Int), Bool>>.globally(
    .implies(
        .atomic(fixedTooManyFailuresProp),
        .next(.atomic(fixedLockedOutProp))
    )
)

// Check the fixed property
let fixedLoginModelChecker = LTLModelChecker<FixedLoginModel>()
let fixedLoginModel = FixedLoginModel()

do {
    let result = try fixedLoginModelChecker.check(formula: tooManyFailuresLeadsToLockout, model: fixedLoginModel)
    print("Verification result for fixed login model: \(result)")
} catch {
    print("Verification error for fixed login model: \(error)")
}
```

### Fixing the Resource Allocation Model

```swift
// Fixed resource allocation model with guaranteed progress
struct FixedResourceModel: KripkeStructure {
    typealias State = (ResourceState, Int) // State + request age counter
    typealias AtomicPropositionIdentifier = String
    
    let requestTimeout = 2 // Maximum time a request can stay in requested state
    
    var allStates: Set<State> {
        var states = Set<State>()
        // Idle state has no age
        states.insert((.idle, 0))
        
        // Requested state has age 0 to timeout
        for age in 0...requestTimeout {
            states.insert((.requested, age))
        }
        
        // Other states have no age
        states.insert((.allocated, 0))
        states.insert((.releasing, 0))
        states.insert((.error, 0))
        
        return states
    }
    
    let initialStates: Set<State> = [(.idle, 0)]
    
    func successors(of state: State) -> Set<State> {
        let (resourceState, age) = state
        
        switch resourceState {
        case .idle:
            return [(.idle, 0), (.requested, 0)]
            
        case .requested:
            // If request has timed out, force transition to error
            if age >= requestTimeout {
                return [(.error, 0)]
            }
            
            // Otherwise, can stay requested (with increased age), 
            // transition to allocated, or error
            return [(.requested, age + 1), (.allocated, 0), (.error, 0)]
            
        case .allocated:
            return [(.releasing, 0), (.error, 0)]
            
        case .releasing:
            return [(.idle, 0), (.error, 0)]
            
        case .error:
            return [(.idle, 0)]
        }
    }
    
    func atomicPropositionsTrue(in state: State) -> Set<String> {
        let (resourceState, age) = state
        var props: Set<String> = []
        
        switch resourceState {
        case .idle:
            props.insert("isIdle")
            props.insert("isAvailable")
        case .requested:
            props.insert("isRequested")
            props.insert("isPending")
            props.insert("requestAge_\(age)")
            
            if age >= requestTimeout {
                props.insert("requestTimedOut")
            }
        case .allocated:
            props.insert("isAllocated")
            props.insert("isInUse")
        case .releasing:
            props.insert("isReleasing")
            props.insert("isPending")
        case .error:
            props.insert("isError")
        }
        
        return props
    }
}

// Propositions for the fixed model
let fixedIsRequested = TemporalKit.makeProposition(
    id: "isRequested",
    name: "Resource is requested",
    evaluate: { (state: (ResourceState, Int)) in state.0 == .requested }
)

let fixedIsAllocated = TemporalKit.makeProposition(
    id: "isAllocated",
    name: "Resource is allocated",
    evaluate: { (state: (ResourceState, Int)) in state.0 == .allocated }
)

let fixedIsError = TemporalKit.makeProposition(
    id: "isError",
    name: "Resource is in error state",
    evaluate: { (state: (ResourceState, Int)) in state.0 == .error }
)

// Same liveness property: "Every request is eventually allocated or errors"
let fixedRequestsEventuallyResolved = LTLFormula<ClosureTemporalProposition<(ResourceState, Int), Bool>>.globally(
    .implies(
        .atomic(fixedIsRequested),
        .eventually(
            .or(
                .atomic(fixedIsAllocated),
                .atomic(fixedIsError)
            )
        )
    )
)

// Check the fixed property
let fixedResourceModelChecker = LTLModelChecker<FixedResourceModel>()
let fixedResourceModel = FixedResourceModel()

do {
    let result = try fixedResourceModelChecker.check(formula: fixedRequestsEventuallyResolved, model: fixedResourceModel)
    print("Verification result for fixed resource model: \(result)")
} catch {
    print("Verification error for fixed resource model: \(error)")
}
```

## 7. Iterative Debugging Process

Debugging counterexamples often requires an iterative process:

1. **Run verification** - Check if your property holds
2. **Analyze counterexample** - If verification fails, analyze the counterexample
3. **Identify the issue** - Determine what's causing the property violation
4. **Fix the model** - Update your model to address the issue
5. **Verify again** - Check if your fix resolves the issue
6. **Repeat if necessary** - Continue until all properties are satisfied

This process helps you systematically improve your models and ensure they meet your requirements.

## 8. Best Practices for Debugging Counterexamples

1. **Start small** - Begin with simple properties and gradually add complexity
2. **Focus on one issue at a time** - Fix issues one by one rather than trying to solve everything at once
3. **Strengthen invariants** - Add additional checks to ensure your model maintains its invariants
4. **Use visualization** - Create visual representations of counterexamples to better understand them
5. **Consider edge cases** - Pay special attention to boundary conditions and rare scenarios
6. **Simplify when possible** - If counterexamples are complex, try to create simpler versions that still demonstrate the issue
7. **Document insights** - Record what you learn from counterexamples for future reference

## Conclusion

Counterexamples are powerful tools for debugging models and improving system designs. By understanding how to interpret and analyze counterexamples in TemporalKit, you can identify and fix issues in your models, ensuring they meet your requirements and behave correctly.

When a property fails, counterexamples show you precisely why, allowing you to diagnose problems and make targeted improvements. This process of model refinement through counterexample analysis is at the heart of effective formal verification.

In the next tutorial, we'll look at how to apply TemporalKit to real-world iOS application development scenarios. 
