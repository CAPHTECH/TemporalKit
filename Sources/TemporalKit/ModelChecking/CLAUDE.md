# LTLModelChecker 実装メモ

## 概要
LTLModelCheckerはLTL（線形時相論理）のモデル検査を行うクラスです。KripkeStructureで表現されたシステムモデルに対して、LTL式が成り立つかを検証します。

## アルゴリズムの理論的背景

### モデル検査の手順
1. **式の否定**: 検証したい式φを否定して¬φを作成
2. **Büchiオートマトン変換**: ¬φを受理するBüchiオートマトンA¬φを構築
3. **積オートマトン構築**: モデルMとA¬φの積オートマトンM×A¬φを構築
4. **空性判定**: 積オートマトンが受理する言語が空かどうかを判定
   - 空の場合: φは成り立つ
   - 非空の場合: 反例が存在（φは成り立たない）

## 主要なプライベートメソッド

### extractPropositions
- **目的**: LTL式とモデルから全ての命題識別子を収集
- **アルゴリズム**: LTL式の再帰的な探索で命題を抽出
- **重要性**: モデル内で真となる全ての命題も追加（アルファベットの互換性を保証）
- **計算量**: O(n) - LTL式のノード数に比例

### convertModelToBuchi
- **目的**: KripkeStructureをBüchi Automatonに変換
- **特徴**: 
  - 全ての状態を受理状態として設定
  - 後続状態がない状態には自己ループを追加
- **計算量**: O(|S| × |T|) - 状態数×遷移数

### constructProductAutomaton
- **目的**: モデルオートマトンと式オートマトンの積を構築
- **アルゴリズム**:
  - シンボルの厳密な一致でのみ遷移を作成
  - 式オートマトンの受理状態を含む積状態のみが受理状態
- **計算量**: O(|S1| × |S2| × |Σ|) - 最悪計算量
- **実装の工夫**: ワークリストアルゴリズムで到達可能な状態のみ探索

### projectRunToModelStates
- **目的**: 積オートマトンの実行をモデル状態の列に射影
- **処理**: ProductStateからモデル状態（s1）を抽出
- **計算量**: O(n) - 実行経路の長さに比例

## 最適化の余地

### 現在の実装の制限
1. extractPropositionsでの重複計算
   - 同じ部分式を複数回探索する可能性
   - メモ化による改善が可能

2. 積オートマトン構築の効率化
   - 到達不可能な状態も構築してしまう可能性
   - オンザフライ構築で改善可能

3. シンボルの一致判定
   - 現在は厳密一致のみ
   - 部分的な一致でも遷移可能な最適化が可能

### 提案される改善
1. **extractPropositionsの最適化**
   ```swift
   // メモ化を使用した実装案
   private var propositionCache: [ObjectIdentifier: Set<PropositionID>] = [:]
   ```

2. **積オートマトンの段階的構築**
   - 必要な状態のみを構築
   - メモリ使用量の削減

3. **並列処理の活用**
   - 独立した状態の探索を並列化
   - Swift Concurrencyを活用

## テスト時の注意点
- プライベートメソッドの直接テストは不可能
- publicなcheck()メソッドを通じて間接的にテスト
- 特定のロジックパスを通るようなテストケースの設計が必要
- カバレッジレポートで各分岐が実行されていることを確認

## パフォーマンス特性
- 小規模モデル（〜100状態）: ミリ秒オーダー
- 中規模モデル（〜1000状態）: 秒オーダー
- 大規模モデル（10000状態以上）: 最適化が必要